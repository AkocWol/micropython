# ===== Alvik Level 3 — Wrong Exit (same style, single-file) =====

# ingebouwde modules via __import__ (geen 'import ...')
_time  = __import__('time')
_math  = __import__('math')
sleep_ms   = _time.sleep_ms
ticks_ms   = _time.ticks_ms
ticks_diff = _time.ticks_diff
atan2      = _math.atan2
sqrt       = _math.sqrt
pi         = _math.pi
floor      = _math.floor

# --- zelfde object & API als jouw project ---
try:
    alvik
except NameError:
    try:
        ArduinoAlvik = __import__('arduino_alvik').ArduinoAlvik
        alvik = ArduinoAlvik(); alvik.begin()
    except Exception as e:
        raise SystemExit("Kon 'alvik' niet initialiseren; check firmware/naam.")

# ----------------- Tunables -----------------
SPEED_FWD         = 22     # snelheid vooruit op het pad
SPEED_BACK        = -18    # snelheid achteruit bij terugzoeken
SPEED_EXIT        = 26     # snelheid bij de exit-bocht
TURN_MS           = 700    # hoe lang draaien voor de exit
EXIT_RUN_MS       = 1200   # vooruit na de bocht om 'van het pad' te gaan
SAMPLE_MS         = 40     # sensorsample-interval
TILE_DWELL        = 4      # min. opeenvolgende samples om een nieuwe tegel te bevestigen
COLOR_H_BINS      = 12     # aantal hue-bins (30° per bin)
COLOR_V_BINS      = 2      # helderheidsbuckets (donker/helder)
DELTA_TILE_TOL    = 1      # tolerantie op bins om jitter te negeren
END_STOP_CM       = 16     # stop aan het eind als front-afstand < deze drempel
END_TIMEOUT_MS    = 18000  # failsafe voor de heenrit (ms)
BACK_TIMEOUT_MS   = 18000  # failsafe voor terugrit (ms)
# --------------------------------------------------------------

# =============== LED helpers — zelfde semantiek ===============
def leds(r,g,b):
    try:
        alvik.left_led.set_color(1 if r else 0, 1 if g else 0, 1 if b else 0)
        alvik.right_led.set_color(1 if r else 0, 1 if g else 0, 1 if b else 0)
    except: pass

def led_wait():   leds(0,0,1)   # blauw: wachten/pauze
def led_go():     leds(0,1,0)   # groen: rijden
def led_stop():   leds(1,0,0)   # rood: nood/stop
def led_turn():   leds(1,0,1)   # paars: draaien
def led_scan():   leds(0,1,1)   # cyaan: scannen/registreren
def led_done():   leds(1,1,1)   # wit: klaar
def led_off():    leds(0,0,0)

def blink_done(times=6, on=120, off=120):
    for _ in range(times):
        led_done(); sleep_ms(on)
        led_off();  sleep_ms(off)

# ===================== Buttons — zelfde API =====================
def ok_pressed():
    try: return bool(alvik.get_touch_ok())
    except: return False

def cancel_pressed():
    try: return bool(alvik.get_touch_cancel())
    except: return False

def wait_ok_released():
    while ok_pressed():
        sleep_ms(50)

def wait_ok_pressed():
    while not ok_pressed():
        led_wait()
        try: alvik.brake()
        except: pass
        sleep_ms(50)

def pause_until_ok():
    while not ok_pressed():
        led_wait()
        try: alvik.brake()
        except: pass
        sleep_ms(100)
    led_go(); sleep_ms(150)

# ===================== Motion helpers =====================
def set_speed(l, r):
    try: alvik.set_wheels_speed(l, r)
    except: pass

def hard_stop():
    led_stop()
    set_speed(0,0)
    try: alvik.brake()
    except: pass
    sleep_ms(120)

def pivot_left(ms=TURN_MS, spd=20):
    led_turn(); set_speed(-spd, spd); sleep_ms(ms); hard_stop()

def pivot_right(ms=TURN_MS, spd=20):
    led_turn(); set_speed(spd, -spd); sleep_ms(ms); hard_stop()

# ===================== Sensing helpers =====================
def front_cm():
    """Neem min(CL,C,CR) uit afstandssensor; mm->cm indien nodig; None bij onzin."""
    try:
        L, CL, C, CR, R = alvik.get_distance()
        xs=[]
        for v in (CL, C, CR):
            v = int(v)
            if v > 1000: v//=10
            if 2 <= v <= 400: xs.append(v)
        if not xs: return None
        return min(xs)
    except: return None

def end_obstacle_detected():
    # Einde van het pad: voorste sensor dichtbij of bumper raakt
    d = front_cm()
    if d is not None and d <= END_STOP_CM:
        return True
    # bumpers/IR edge (best-effort)
    for fn in ("get_bumpers","get_touch_front","is_bumper_pressed"):
        try:
            v = getattr(alvik, fn)()
            if isinstance(v, (tuple,list)):
                if any(bool(x) for x in v): return True
            elif isinstance(v, dict):
                if any(bool(x) for x in v.values()): return True
            else:
                if bool(v): return True
        except: pass
    return False

# ---- Color read (geen pre-scan; we quantizen on-the-fly) ----
def read_rgb01():
    """
    Lees RGB van de kleurensensor en normaliseer naar 0..1.
    Ondersteunt: get_color(), get_rgb(), get_color_rgb(), line sensor rgb.
    """
    # voorkeurs-API's
    for fn in ("get_color","get_rgb","get_color_rgb","get_line_color","read_color"):
        try:
            v = getattr(alvik, fn)()
            # tuple/list
            if isinstance(v,(tuple,list)) and len(v)>=3:
                r,g,b = float(v[0]), float(v[1]), float(v[2])
            elif isinstance(v, dict):
                r = float(v.get('r', v.get('red', 0)))
                g = float(v.get('g', v.get('green', 0)))
                b = float(v.get('b', v.get('blue', 0)))
            else:
                continue
            # normaliseer
            mx = max(1.0, r, g, b)
            # detecteer 0..255 of 0..1
            if mx > 1.5:  # waarschijnlijk 0..255
                r/=255.0; g/=255.0; b/=255.0
            return max(0.0,min(1.0,r)), max(0.0,min(1.0,g)), max(0.0,min(1.0,b))
        except: pass
    # fallback: probeer lijnsensor (3 fotodiodes) als "rgb"
    try:
        ls = alvik.get_line_sensors()  # (L,C,R)
        if isinstance(ls,(tuple,list)) and len(ls)>=3:
            r,g,b = float(ls[0]), float(ls[1]), float(ls[2])
            mx = max(1.0, r, g, b)
            r/=mx; g/=mx; b/=mx
            return r,g,b
    except: pass
    return 0.0,0.0,0.0

def rgb_to_hvbin(r,g,b):
    """
    Zet RGB naar hue/brightness bins (robust; geen voorafgaande calibratie).
    - Hue bin: 0..COLOR_H_BINS-1
    - Value bin (helderheid): 0..COLOR_V_BINS-1
    """
    # hue via 2D projectie; stabiel genoeg voor tegels
    # mijd HSV met deling door kleine S; gebruik atan2 met differntial channels
    x = (2*r - g - b)  # r - (g+b)/2 * 2
    y = (sqrt(3.0) * (g - b))
    ang = atan2(y, x)  # -pi..pi
    if ang < 0: ang += 2*pi
    h  = ang * (180.0/pi)  # 0..360
    hbin = int(floor((h / 360.0) * COLOR_H_BINS))
    if hbin >= COLOR_H_BINS: hbin = COLOR_H_BINS-1
    v = max(r,g,b)
    vbin = 0 if v < 0.35 else 1  # grofweg donker / helder
    return hbin, vbin

def color_bucket():
    r,g,b = read_rgb01()
    return rgb_to_hvbin(r,g,b)

# ---- Tile detection with hysteresis ----
_last_bucket = None
_dwell = 0

def detect_tile_change():
    """
    Retourneert (is_new, bucket) wanneer we stabiel op een NIEUWE tegel staan.
    gebruikt TILE_DWELL om ruis te dempen.
    """
    global _last_bucket, _dwell
    cur = color_bucket()
    if _last_bucket is None:
        _last_bucket = cur
        _dwell = 1
        return False, cur
    # dezelfde bin?
    if abs(cur[0]-_last_bucket[0]) <= DELTA_TILE_TOL and abs(cur[1]-_last_bucket[1]) <= DELTA_TILE_TOL:
        _dwell += 1
        # nieuw pas melden wanneer we net zijn INGESTAPT op deze tegel
        if _dwell == TILE_DWELL:
            return True, cur
        return False, cur
    else:
        # nieuwe kandidaat, reset dwell op 1 en wacht even op stabilisatie
        _last_bucket = cur
        _dwell = 1
        return False, cur

# ===================== Core behaviors =====================
def forward_across_and_record(colors_list, counts_dict):
    """
    Objective 1 + 2:
      - Rijd vooruit en registreer elke nieuwe tegel (pas bij stabiele IN-stap).
      - Stop bij obstakel aan het einde van het pad.
    """
    led_scan()
    t0 = ticks_ms()
    set_speed(SPEED_FWD, SPEED_FWD)
    # forceer eerste meting als eerste tegel
    _ = detect_tile_change()  # seed
    while True:
        if cancel_pressed():
            hard_stop()
            pause_until_ok()
            led_scan()
            set_speed(SPEED_FWD, SPEED_FWD)

        new, bucket = detect_tile_change()
        if new:
            colors_list.append(bucket)
            counts_dict[bucket] = counts_dict.get(bucket, 0) + 1

        # live bijwerken, ook als dwell niet gehaald (voor redundantie)
        counts_dict[bucket] = counts_dict.get(bucket, 0) + 0  # no-op ensures key exists

        if end_obstacle_detected():
            hard_stop()
            return True

        if ticks_diff(ticks_ms(), t0) > END_TIMEOUT_MS:
            hard_stop()
            return True

        sleep_ms(SAMPLE_MS)

def pick_unique_color(counts_dict):
    """
    Objective 3: vind de kleur (bucket) die precies 1x voorkwam.
    Als er meerdere zijn: kies de laatst geziene (logisch bij dit parcours).
    """
    uniques = [k for (k,v) in counts_dict.items() if v == 1]
    if not uniques:
        return None
    # simpele strategie: meest recente unieke (hoogste 'moment' in colors_list is niet bekend;
    # hier kiezen we de laatste unieke op alfabet van bins als benadering)
    uniques.sort()
    return uniques[-1]

def reverse_until_bucket(target_bucket):
    """
    Objective 4 (deel 1): rijd achteruit tot de unieke tegel terug is.
    """
    led_go()
    set_speed(SPEED_BACK, SPEED_BACK)
    t0 = ticks_ms()
    # reset dwell state zodat we pas meldden als we stabiel OP de tegel zijn
    global _last_bucket, _dwell
    _last_bucket = None; _dwell = 0

    while True:
        if cancel_pressed():
            hard_stop()
            pause_until_ok()
            set_speed(SPEED_BACK, SPEED_BACK)

        new, bucket = detect_tile_change()
        # we willen niet 'new' van eerste reset, daarom check op dwell-trigger
        if _dwell >= TILE_DWELL:
            # check nabijheid tot target in bin-ruimte (tolerantie)
            if abs(bucket[0]-target_bucket[0]) <= DELTA_TILE_TOL and abs(bucket[1]-target_bucket[1]) <= DELTA_TILE_TOL:
                hard_stop()
                return True

        if ticks_diff(ticks_ms(), t0) > BACK_TIMEOUT_MS:
            hard_stop()
            return False

        sleep_ms(SAMPLE_MS)

def exit_turn_and_go(direction="auto"):
    """
    Objective 4 (deel 2): bocht maken en van het pad af rijden.
    direction:
      - "left"/"right" forceren, of "auto" → kies kant met iets meer ruimte.
    """
    # simpele ruimte-inschatting via zij-afstanden (best-effort)
    go_left = True
    if direction == "auto":
        l_ok = r_ok = 0
        try:
            L, CL, C, CR, R = alvik.get_distance()
            # grotere waarde = verder vrij
            l_ok = int(L) if isinstance(L, (int,float)) else 0
            r_ok = int(R) if isinstance(R, (int,float)) else 0
        except:
            pass
        go_left = (l_ok >= r_ok)
    elif direction == "right":
        go_left = False

    if go_left:
        pivot_left(ms=TURN_MS, spd=22)
    else:
        pivot_right(ms=TURN_MS, spd=22)

    led_go()
    set_speed(SPEED_EXIT, SPEED_EXIT)
    sleep_ms(EXIT_RUN_MS)
    hard_stop()
    return True

# ===================== Celebration (Bonus) =====================
def celebrate():
    # klein dansje: links-rechts wiebelen + blink
    for _ in range(3):
        leds(1,1,1); sleep_ms(120); led_off(); sleep_ms(80)
    for _ in range(3):
        set_speed(26,-26); sleep_ms(250); set_speed(-26,26); sleep_ms(250)
    hard_stop()
    blink_done(times=6, on=120, off=120)

# ===================== Main — zelfde flow als je project =====================
led_wait()
wait_ok_released()
wait_ok_pressed()

try:
    while True:
        while not cancel_pressed():
            colors_list = []      # volgorde van nieuw gedetecteerde tegels
            counts_dict = {}      # bucket -> count
            # Heenweg: kleuren registreren tot obstakel
            if not forward_across_and_record(colors_list, counts_dict):
                continue

            # Unieke kleur bepalen
            target = pick_unique_color(counts_dict)

            # Geen unieke gevonden? Plan B: kies de allereerste of laatste tegel
            if target is None:
                if colors_list:
                    target = colors_list[-1]
                else:
                    # niets gezien → graceful finish
                    blink_done(times=3, on=160, off=160)
                    raise SystemExit

            # Terugrijden tot de unieke tegel is gevonden
            if reverse_until_bucket(target):
                # Exit: bocht + doorrijden
                exit_turn_and_go(direction="auto")
                celebrate()
                raise SystemExit
            else:
                # Als terugzoeken faalt, stop netjes
                hard_stop()
                blink_done(times=4, on=140, off=140)
                raise SystemExit

        # CANCEL → pauze tot OK
        hard_stop()
        pause_until_ok()

except KeyboardInterrupt:
    try: alvik.stop()
    except: pass
