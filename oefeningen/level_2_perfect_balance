# ==== Alvik L2 — Buttons Always + Infinite Run + Final Flat Stop ====
_time=__import__('time'); _math=__import__('math')
sleep_ms=_time.sleep_ms; ticks_ms=_time.ticks_ms; ticks_diff=_time.ticks_diff
atan2=_math.atan2; sqrt=_math.sqrt; pi=_math.pi

# --- board ---
try: alvik
except NameError:
    ArduinoAlvik=__import__('arduino_alvik').ArduinoAlvik
    alvik=ArduinoAlvik(); alvik.begin()

# ===== Tunables (kort & snel) =====
DIR=1                     # 1=vooruit, -1=achteruit als jouw wiring zo is
TRIM_L=0.0; TRIM_R=0.0
SPEED_UP=28; SPEED_UP_SLOW=20; SPEED_DOWN=24
SAMPLE_DT_MS=15
UP_MIN_DEG=4; UP_SLOW_DEG=10; TILT_DROP_DEG=7

MID_ZERO_DEG=5           # midden = |pitch| <= 5°
MID_STABLE_SAMPLES=1     # 1 sample is genoeg (klein midden)
MID_WINDOW_MS=900        # venster na crest/klap

FINAL_ZERO_DEG=4         # eindsituatie: |pitch| <= 4° (vlak op tafel)
FINAL_STABLE_SAMPLES=4   # 4 opeenvolgende vlakke metingen
FINAL_MIN_MS=400         # pas vlak toestaan >= 0.4s na midden
# ================================

# --- LEDs ---
def _led(rgb):
    try: r,g,b=rgb; alvik.left_led.set_color(r,g,b); alvik.right_led.set_color(r,g,b)
    except: pass
def led_wait():  _led((0,0,1))
def led_go():    _led((0,1,0))
def led_pause(): _led((1,1,0))
def led_done():  _led((1,1,1))

# --- Buttons (altijd responsief) ---
def ok_pressed():
    try: return bool(alvik.get_touch_ok())
    except: return False
def cancel_pressed():
    try: return bool(alvik.get_touch_cancel())
    except: return False

def pause_until_ok():
    # universele pauze: stopt motoren en wacht op OK
    stop_now(); led_pause()
    while not ok_pressed():
        sleep_ms(40)
    sleep_ms(120)  # kleine debounce
    led_go()

# --- Motion ---
def stop_now():
    try: alvik.set_wheels_speed(0,0); alvik.brake()
    except: pass
def forward(v):
    L=DIR*v*(1.0+TRIM_L); R=DIR*v*(1.0+TRIM_R)
    try: alvik.set_wheels_speed(L,R)
    except: pass

# --- Distance (optioneel; hier niet nodig) ---
def get_distance_cm():
    for fn in ("get_distance","get_distance_cm","get_front_distance","get_ultrasonic_cm","get_tof_cm"):
        try:
            d=getattr(alvik,fn)()
            if isinstance(d,(int,float)): return float(d)
            if isinstance(d,dict):
                for k in ("cm","distance","front","tof"):
                    if k in d and isinstance(d[k],(int,float)): return float(d[k])
        except: pass
    return None

# --- Pitch (euler → accel fallback) ---
def _raw_pitch():
    for fn in ("get_euler","get_orientation"):
        try:
            e=getattr(alvik,fn)()
            if isinstance(e,(tuple,list)) and len(e)>=2: return float(e[1])
            if isinstance(e,dict) and "pitch" in e: return float(e["pitch"])
        except: pass
    ax=ay=az=None
    for fn in ("get_accelerometer","get_accel","accel"):
        try:
            a=getattr(alvik,fn)()
            if isinstance(a,(tuple,list)) and len(a)>=3:
                ax,ay,az=float(a[0]),float(a[1]),float(a[2]); break
            if isinstance(a,dict):
                ax=float(a.get("ax",a.get("x",0))); ay=float(a.get("ay",a.get("y",0))); az=float(a.get("az",a.get("z",0))); break
        except: pass
    if ax is None:
        try:
            imu=alvik.get_imu()
            if isinstance(imu,(tuple,list)) and len(imu)>=3:
                ax,ay,az=float(imu[0]),float(imu[1]),float(imu[2])
            elif isinstance(imu,dict):
                ax=float(imu.get("ax",imu.get("x",0))); ay=float(imu.get("ay",imu.get("y",0))); az=float(imu.get("az",imu.get("z",0)))
        except: pass
    if ax is None: return 0.0
    return atan2(-ax, sqrt(ay*ay+az*az))*(180.0/pi)

def get_pitch_deg():
    p=_raw_pitch()
    p = -p   # <<< BELANGRIJK: jouw IMU-as is omgekeerd (positief = omhoog)
    return p

# ================== Fases ==================
def go_to_middle_and_blink():
    """
    Heuvel op -> zodra midden (heel kort vlak) wordt gezien: stop + korte knipper.
    Knoppen werken altijd: CANCEL pauzeert, OK hervat.
    """
    led_go(); forward(SPEED_UP)
    climbing=False; flat=0; crest=False
    prev=get_pitch_deg()
    while True:
        if cancel_pressed(): pause_until_ok(); forward(SPEED_UP)

        p=get_pitch_deg(); dp=p-(prev if prev is not None else p)

        # klimmen markeren + snelheid regelen
        if p>=UP_MIN_DEG: climbing=True
        forward(SPEED_UP_SLOW if p>=UP_SLOW_DEG else SPEED_UP)

        # crest/klap arming
        if climbing and not crest:
            if dp<=-TILT_DROP_DEG or (prev is not None and prev>p):
                crest=True; t_crest=ticks_ms()

        # midden-criteria
        mid=False
        if climbing and abs(p)<=MID_ZERO_DEG:
            flat += 1
            if flat>=MID_STABLE_SAMPLES: mid=True
        else:
            flat = 0
        if crest and ticks_diff(ticks_ms(),t_crest)<=MID_WINDOW_MS and abs(p)<=MID_ZERO_DEG:
            mid=True

        if mid:
            stop_now()
            # 3x kort knipperen, daarna meteen door naar volgende fase
            for _ in range(3):
                led_done(); sleep_ms(100)
                led_go();  sleep_ms(100)
            return  # door naar infinite run

        prev=p; sleep_ms(SAMPLE_DT_MS)

def infinite_run_until_final_flat():
    """
    Na midden blijft hij eindeloos vooruit rijden.
    Jij tilt 'm op en zet 'm vlak op tafel: bij stabiel 'vlak' stop + knipper.
    """
    led_go(); forward(SPEED_DOWN)
    flat=0
    t_start=ticks_ms()
    while True:
        if cancel_pressed(): pause_until_ok(); forward(SPEED_DOWN)

        p=get_pitch_deg()
        # pas vlak accepteren na een korte minimale tijd (voorkomt direct retrigger)
        if ticks_diff(ticks_ms(), t_start) >= FINAL_MIN_MS and abs(p)<=FINAL_ZERO_DEG:
            flat += 1
        else:
            flat = 0

        if flat >= FINAL_STABLE_SAMPLES:
            stop_now()
            # eind-knipper en AAN blijven (geen shutdown)
            for _ in range(4):
                led_done(); sleep_ms(120)
                led_go();  sleep_ms(120)
            return

        sleep_ms(SAMPLE_DT_MS)

# ================== MAIN ==================
def wait_ok():
    while not ok_pressed():
        led_wait()
        try: alvik.brake()
        except: pass
        sleep_ms(50)
    sleep_ms(120)  # debounce

led_wait(); wait_ok()
try:
    go_to_middle_and_blink()       # fase 1: midden vinden
    infinite_run_until_final_flat()# fase 2: oneindig rijden tot vlak op tafel
except KeyboardInterrupt:
    stop_now(); led_go()
